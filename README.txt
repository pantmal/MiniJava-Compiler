Ονοματεπώνυμο: Παντελεήμων Μαλέκας
Α.Μ: 1115201600268

Compilation command: make 
Run command: java Main [inputfile1] [inputfile2] ... [inputfileN]

Brief description of the programs: For the second assignment I created two Visitors that extend from the generated GJDepthFirst Visitor, from the generated visitors. The first compilation command uses the -te flag, so all visitors support the use of Exceptions, in order to stop the execution if a program has any semantic errors. The First Visitor performs declaration checks and adds all the necessary symbols in a Symbol Table object. After that, the Second Visitor performs type checking using the Symbol Table from the First Visitor. After finishing all checks, the offset table is created with the use of the Offset Table class (if there aren't any errors in the program). If we encounter any error, the execution stops and we move on to the next program.

Here are some details about each .java file.

SymbolTable.java: This file contains all the necessary structures for the implementation of our Symbol Table. The Symbol Table class consists of a LinkedHashMap. Each key is the class id and its key a corresponding Class Table object. The ClassTable class contains all the fields and method names of a class, as well as some additional information. For the fields a LinkedHashMap is used where each key is the variable name and its key is its type. For the method names a LinkedHashMap is used where each key is the method name and its key is a custom Tuple class, where one part is its type and the other is a MethodTable object, which is used to store the variables of a function. Specifically, a MethodTable is used to store the parameters and local variables of a method (if any), again with the use of LinkedHashMaps. Additional information can be seen at the comments of the program.

FirstVisitor.java: The First Visitor will create the Symbol Table so the Second Visitor can perform type checks. It add symbols from every declaration and also checks if the declarations are correct. Additionally, the First Visitor checks if a child class has its mother defined before it and also checks if a function is overriden properly, if we're in a hierarchy. Finally every non-primitive type is added in a list. After the first visitor ends evaluating, the main function will check if the idList has any undeclared types.

SecondVisitor.java: The Second Visitor will perform type checks in our program, using the SymbolTable of the First Visitor. In every "declaration" visit the program will update two fields: curr_class and curr_method. They are used so we can know the scope we're on. Also, in a method declaration we check if the return type is correct in the "return expression" term (special care is taken for subtypes). Following this, we move on to every statement and expression to perform the necessary checks. In an AssignmentStatement we check if the expression has the same type as the identifier type (special care is taken for subtypes). In an ArrayAssignmentStatement, we check if a correct type is assigned in the rigth array type. IfStatement and WhileStatemts must have a boolean expression in their condition and PrintStatements must have an int expression in the argument. In the Expressions, similar checks are performed and each Expression visit returns the right type. In the Identifier visit, we check whether an identifier is declared or not, going through each table. First we check if the variable is in the local or parameter table of the method we're in. If not we check the field table of the class we're in. If not we also check the field table of the first mother we find (if the class is in hierarchy). Additional information about type checking can be seen in the comments of the program.

OffsetTable.java: Offset Table will create the offsets of a semantically correct Minijava program. For every class in the classId table, we get its Class Table, skipping the Main class since it doesn't have any fields or methods. First we get the field offsets. If it's the first field we print 0, except if we're in a hierarchy. If so, get the offset sum of the previous mother class. If it's not the first item we will go to every previous field and create the sum. Also I store the field offset sum and last type in the Class Table, in case they are needed by a child class. Then we move on to the method offsets, where similar work is performed. Additional information can be seen at the comments of the program.

Main.java: The Main Class adds together our previous programs. After parsing the input program, if the parsing was successful, we move on to the FirstVisitor which will create the Symbol Table and perform declaration checks. After the First Visitor ends evaluating, the main function will check if the idList has any undeclared types. If our program is free of declaration errors, we go to the second visitor which will perform type checking. Finally, if there aren't any type errors, we create the offset table with the OffsetTable class.

Any additional information can be seen at the comments of each program. 
